<details>
<summary>Lecture 02</summary>

# Lecture 02 #
## Software Development ##
  * Process of creating and maintaining software
  * typical phases
    * understand the problem & gather requirements
    * design the solution
    * implement it
    * test
    * deploy
    * maintain

## Software Development Methodologies ##
  * Dictates how the development phases is executed in practice
  1. Waterfall 
  2. Agile

### Waterfall (a.k.a traditional) Methodology ###
  * focuses on a linear, top to bottom development
  * sequential, non-iterative process in which progress is seen as flowing steadily downwards through phases
    1. Problem Statement
    2. Analysis
    3. Design
    4. Implementation 
    5. Testing
    6. Deployment
    
#### Limitations of Waterfall ####
  * Does not accomodate Change in design. 
  * If all features are not accounted for during the design phase, then it's game over

### Agile Methodology ###
  * based on iterative and incremental development
  * Dev cycle is the same that of Watefall, except that it is iterative -- i.e. the process repeats
  * follows the agile manifesto
  * Is collaborative and client focused
    * client is involved throughout the development because they are the ultimate source of information
    * client guides the project
  * Improvments with each iteration
  * Focus on Minimum Viable Products (MVPs) over short periods of time
  * Backlog to keep track of features and requirements
  * promote sustainable development

#### Agile Manifesto Principles ####
  * Regular Delivery of Software
    * "Working software over comprehensive documentation" (#2)
    * Deliver working software frequently and regularly
    * Working software is the primary measure of success
    * satisfy the customer through early and continuous delivery of MVPs
  * Team Communication
    * "Individuals and and interactions over processes and tools" (#1)
    * "Customer collaboration over contract negotiation" (#3)
    * business people and developers must work together daily throughout the project
    * convey information to and within the team face to face. it's the most effective way
    * regularly reflect on how to become more effective and tweak behaviour accordingly.
    * build projects around motivated individuals. give them the env and trust to get the job done
  * Design Excellence
    * "Responding to change over following a plan" (#4)
    * continuous attention to the technical excellence and good design enhances agility
    * Simplicity is essential
      * Simplicity = art of maximising the amount of work not done
    * be open to changing requirements, even late in development

### Show down ###
Waterfall                                | Agile
-----------------------------------------|--------------------------------------
\+ Easy learning curve                   | + Adaptability and flexibility
\+ Clear Deadlines                       | + Immediate user feedback
\+ Well-defined milestones               | + Test driven development
\+ Requires stability                    | + Teamwork
\+ Predictable, and Easy to manage time  | - Unpredictable timeline
\- Very low flexibility                  | - High commitment 
\- Requirements must be known at start   | - Skill dependent teans  
\- Tendency to neglect testing           | - Tendency to neglect documentation


## Scrum (implements the Agile Framework)  ##
  * lightweight, people-centric framework for organising and managing work

### Scrum Roles ###
  * Product Owner
    * knows the product; communicates what the client wants
  * Scrum Master
    * project manager
  * Development Team
    * people who get the work done
### Scrum Activities ###
### Artifacts  ###
  * Product Backlog
  * Scrum Backlog
  * Potentially Shippable Product
</details>

-------

<details>
<summary>Lecture 03</summary>

# Lecture 03 #
## Software Design ##
  * *process* in which a **blueprint** is developed from which we can construct a software artifact
  * *process* of **defining** the architecture, components, interfaces and other **characteristics of a system**, and its result
  * i.e. understand the problem, design a solution, implement the solution

## Software Design Goals ##
  * Reliability
    * each component of the app should be responsible for a specific property an behaviour
    * supports validation and testing
      * does it do what it should?
      * is it done correctly and robustly?
        * Correct = produces correct answer
        * Robust = is correct regardless of the input; deals with a variety of inputs and unexpected errors
  * Reusability
    * components are modular and independent
    * takes advantage of existing code libraries
    * supports timely production of large-scale software
  * Extensibility
    * components can be changed and added
    * supports maintenance and evolution of software
  * Flexibility
    * modifications can be made without affecting many components

### Object Oriented Programming ###
  * supports all the aforementioned goals
  * all about classes and objects
    * classes: blueprint for objects defined what an object can store and do
    * objects: instance of a class

#### Object-Oriented Principles (mnemonic: A PIE) ####
  * Abstraction 
    * extracting releavant features and removing what is unnecessary
    * allows modeling and representing objects in the simplest manner
    * GOAL: simplify the description of an object to its essentials
  * Encapsulation
    * binding certain features together in order to hide and protect them
  * Inheritance
    * allows a new class to be defined based upon an existing class
    * creates a parent/super-child/sub class relationship
    * *is a* relationship bw parent and child
  * Polymorphism
    * lit. "many forms"
    * allows performing the behaviour corrosponding with the type of what we're working with
    * brings flexibility; we can do the right thing at the right time

## From Problem to Soln ##
  1. Gather your requirements
    * What should the software do?
  2. Describe the solution
    * How do users use this solution?
  3. Identify the most important objects
    * What classes do we need?
  4. Identify the interactions between objects
    * What responsibilities and behaviours do we need?
  5. Create a class diagram
    * Visual rep of classes

### Gathering Requirements ###
  * *Functional Requirements*: What does it do?
    * Features and capabilities
    * must-haves over nice-to-haves
    * E.G: 
      * Customer must be able to see their balance
      * Customer must be able to pay their bill online
      * Customer must be able to open a new account online
  * *Non-functional Requirements*: Other
    * Help, documentation, performance, support
    * E.G:
      * Customer must be able to load page in under 5 seconds
      * Customer data must be encrypted to comply with ... 
      * Server must have a 99% uptime 

#### FURPS / FURPS+ ####
represents a model for classifying software quality attributes
  * **F**unctional: features, capabilities, security
  * **U**sability: human factors, help, documentation
  * **R**eliability: frequency of failure, recoverability
  * **P**erformance: speed, resouce consumption, throughput, scalability
  * **S**upportability: adaptability, maintainability, internationalisation, repair speed
  * **+** more requirements
</details>

-----

<details>
<summary>Lecture 04</summary>

# Lecture 04 #
## From Requirements to solution ##
Once we know what the functional requirements are, we need to describe the system from the user's PoV.

Agile approach advocates the following two tools:
  1. Use Cases
    * defines the interactions bw actos and the sys to accomplish a goal
  2. User Stories
<details>

