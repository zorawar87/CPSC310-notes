# Lecture Notes 02 #

## Software Development ##
  * Process of creating and maintaining software
  * typical phases
    * understand the problem & gather requirements
    * design the solution
    * implement it
    * test
    * deploy
    * maintain

## Software Development Methodologies ##
  * Dictates how the development phases is executed in practice
  1. Waterfall 
  2. Agile

### Waterfall (a.k.a traditional) Methodology ###
  * focuses on a linear, top to bottom development
  * sequential, non-iterative process in which progress is seen as flowing steadily downwards through phases
    1. Problem Statement
    2. Analysis
    3. Design
    4. Implementation 
    5. Testing
    6. Deployment
    
#### Limitations of Waterfall ####
  * Does not accomodate Change in design. 
  * If all features are not accounted for during the design phase, then it's game over

### Agile Methodology ###
  * based on iterative and incremental development
  * Dev cycle is the same that of Watefall, except that it is iterative -- i.e. the process repeats
  * follows the agile manifesto
  * Is collaborative and client focused
    * client is involved throughout the development because they are the ultimate source of information
    * client guides the project
  * Improvments with each iteration
  * Focus on Minimum Viable Products (MVPs) over short periods of time
  * Backlog to keep track of features and requirements
  * promote sustainable development

#### Agile Manifesto Principles ####
  * Regular Delivery of Software
    * "Working software over comprehensive documentation" (#2)
    * Deliver working software frequently and regularly
    * Working software is the primary measure of success
    * satisfy the customer through early and continuous delivery of MVPs
  * Team Communication
    * "Individuals and and interactions over processes and tools" (#1)
    * "Customer collaboration over contract negotiation" (#3)
    * business people and developers must work together daily throughout the project
    * convey information to and within the team face to face. it's the most effective way
    * regularly reflect on how to become more effective and tweak behaviour accordingly.
    * build projects around motivated individuals. give them the env and trust to get the job done
  * Design Excellence
    * "Responding to change over following a plan" (#4)
    * continuous attention to the technical excellence and good design enhances agility
    * Simplicity is essential
      * Simplicity = art of maximising the amount of work not done
    * be open to changing requirements, even late in development

### Show down ###
Waterfall                               | Agile
--------------------------------------------------------------------------
+ Easy learning curve                   | + Adaptability and flexibility
+ Clear Deadlines                       | + Immediate user feedback
+ Well-defined milestones               | + Test driven development
+ Requires stability                    | + Teamwork
+ Predictable, and Easy to manage time  | - Unpredictable timeline
- Very low flexibility                  | - High commitment 
- Requirements must be known at start   | - Skill dependent teans  
- Tendency to neglect testing           | - Tendency to neglect documentation


## Scrum (implements the Agile Framework)  ##
  * lightweight, people-centric framework for organising and managing work

### Scrum Roles ###
  * Product Owner
    * knows the product; communicates what the client wants
  * Scrum Master
    * project manager
  * Development Team
    * people who get the work done
### Scrum Activities ###
### Artifacts  ###
  * Product Backlog
  * Scrum Backlog
  * Potentially Shippable Product

-------

# Lecture Notes 03 #

## Software Design ##
  * *process* in which a **blueprint** is developed from which we can construct a software artifact
  * *process* of **defining** the architecture, components, interfaces and other **characteristics of a system**, and its result
  * i.e. understand the problem, design a solution, implement the solution

### Software Design Goals ###
  * Reliability
  * Reusability
  * Extensibility
  * Flexibility
